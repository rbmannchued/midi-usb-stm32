#include <stdlib.h>
#include <stdint.h>
#include <libopencm3/usb/usbd.h>
#include <libopencm3/usb/audio.h>
#include <libopencm3/usb/midi.h>
#include <libopencm3/cm3/scb.h>
#include <libopencm3/cm3/systick.h>
#include <libopencm3/cm3/nvic.h>
#include <libopencm3/cm3/scb.h>
#include <libopencm3/stm32/desig.h>
#include <libopencm3/stm32/exti.h>
#include <libopencm3/stm32/rcc.h>
#include <libopencm3/stm32/flash.h>
#include <libopencm3/stm32/gpio.h>
#include <libopencm3/stm32/adc.h>
#include <libopencm3/stm32/pwr.h>
#include <libopencmsis/core_cm3.h>
static usbd_device *usbd_dev;


static const struct usb_device_descriptor dev_descr = {
    .bLength = USB_DT_DEVICE_SIZE,
    .bDescriptorType = USB_DT_DEVICE,
    .bcdUSB = 0x0200,
    .bDeviceClass = 0,
    .bDeviceSubClass = 0,
    .bMaxPacketSize0 = 64,
    .idVendor = 0x0666, // example
    .idProduct = 0x0815, // example
    .bcdDevice = 0x0101,
    .iManufacturer = 1,
    .iProduct = 2,
    .iSerialNumber = 3,
    .bNumConfigurations = 1,
};

static const struct usb_midi_endpoint_descriptor midi_usb_endp[] = {
    {
        .head = {
            .bLength = sizeof(struct usb_midi_endpoint_descriptor),
            .bDescriptorType = USB_AUDIO_DT_CS_ENDPOINT,
            .bDescriptorSubType= USB_MIDI_SUBTYPE_MS_GENERAL,
            .bNumEmbMIDIJack = 1,
        },
        .jack[0] = {
            .baAssocJackID = 0x03,
        },
    }
};
static const struct usb_endpoint_descriptor usb_endp[] = {
    {
        .bLength = USB_DT_ENDPOINT_SIZE,
        .bDescriptorType = USB_DT_ENDPOINT,
        .bEndpointAddress = 0x81,  // Endpoint de saÃ­da (Bulk, IN)
        .bmAttributes = USB_ENDPOINT_ATTR_BULK,
        .wMaxPacketSize = 0x40,
        .bInterval = 0x00,
        .extra = NULL,
        .extralen = 0
    }
};

static const struct {
    struct usb_audio_header_descriptor_head header_head;
    struct usb_audio_header_descriptor_body header_body;
}__attribute__((packed)) audio_control_functional_descriptors = {
    .header_head = {
        .bLength = sizeof(struct usb_audio_header_descriptor_head) +
            1 * sizeof(struct usb_audio_header_descriptor_body),
        .bDescriptorType = USB_AUDIO_DT_CS_INTERFACE,
        .bDescriptorSubtype = USB_AUDIO_TYPE_HEADER,
        .bcdADC = 0x0100,
        .wTotalLength = 
            sizeof(struct usb_audio_header_descriptor_head) +
            1 * sizeof(struct usb_audio_header_descriptor_body),
        .binCollection = 1,
    },
    .header_body = {
        .baInterfaceNr = 0x01,
    },
};

static const struct usb_interface_descriptor audio_control_iface[] = {{
	.bLength = USB_DT_INTERFACE_SIZE,
	.bDescriptorType = USB_DT_INTERFACE,
	.bInterfaceNumber = 0,
	.bAlternateSetting = 0,
	.bNumEndpoints = 0,
	.bInterfaceClass = USB_CLASS_AUDIO,
	.bInterfaceSubClass = USB_AUDIO_SUBCLASS_CONTROL,
	.bInterfaceProtocol = 0,
	.iInterface = 0,

	.extra = &audio_control_functional_descriptors,
	.extralen = sizeof(audio_control_functional_descriptors)
} };


static const struct {
    struct usb_midi_header_descriptor header;
    struct usb_midi_in_jack_descriptor in_embedded;
    struct usb_midi_out_jack_descriptor out_embedded;
} __attribute__ ((packed)) midi_streaming_functional_descriptors = {
    .header = {
        .bLength = sizeof(struct usb_midi_header_descriptor),
        .bDescriptorType = USB_AUDIO_DT_CS_INTERFACE,
        .bDescriptorSubtype = USB_MIDI_SUBTYPE_MS_HEADER,
        .bcdMSC = 0x0100,
        .wTotalLength = sizeof(midi_streaming_functional_descriptors),
    },
    .in_embedded = {
        .bLength = sizeof(struct usb_midi_in_jack_descriptor),
        .bDescriptorType = USB_AUDIO_DT_CS_INTERFACE,
        .bDescriptorSubtype = USB_MIDI_SUBTYPE_MIDI_IN_JACK,
        .bJackType = USB_MIDI_JACK_TYPE_EMBEDDED,
        .bJackID = 0x01,
        .iJack = 0x00,
    },
    .out_embedded = {
        .head = {
            .bLength = sizeof(struct usb_midi_out_jack_descriptor),
            .bDescriptorType = USB_AUDIO_DT_CS_INTERFACE,
            .bDescriptorSubtype = USB_MIDI_SUBTYPE_MIDI_OUT_JACK,
            .bJackType = USB_MIDI_JACK_TYPE_EMBEDDED,
            .bJackID = 0x02,
            .bNrInputPins = 1,
        },
        .source[0] = {
            .baSourceID = 0x01,  // Fonte: Jack de entrada embutido
            .baSourcePin = 0x01,
        },
        .tail = {
            .iJack = 0x00,
        },
    },
};


static const struct usb_interface_descriptor midi_streaming_iface[] = {
    {
        .bLength = USB_DT_INTERFACE_SIZE,
        .bDescriptorType = USB_DT_INTERFACE,
        .bInterfaceNumber = 1,
        .bAlternateSetting = 0,
        .bNumEndpoints = 1,
        .bInterfaceClass = USB_CLASS_AUDIO,
        .bInterfaceSubClass = USB_AUDIO_SUBCLASS_MIDISTREAMING,
        .bInterfaceProtocol = 0,
        .iInterface = 0,

        .endpoint = usb_endp,

        .extra = &midi_streaming_functional_descriptors,
        .extralen = sizeof(midi_streaming_functional_descriptors)
    }
};

static const struct usb_interface ifaces[] = {
    {
        .num_altsetting = 1,
        .altsetting = audio_control_iface,
    },
    {
        .num_altsetting = 1,
        .altsetting = midi_streaming_iface,
    }
};

static const struct usb_config_descriptor config = {
    .bLength = USB_DT_CONFIGURATION_SIZE,
    .bDescriptorType = USB_DT_CONFIGURATION,
    .wTotalLength = 0,
    .bNumInterfaces = 2, 
    .bConfigurationValue = 1,
    .iConfiguration = 0,

    .bmAttributes = 0x80,
    .bMaxPower = 0x64,
    .interface = ifaces,
};


static const char *usb_strings[] = {
    "Rafael Bormann Chueds",
    "Midi Dispositivo",
    "AHSM0000\0"
};

uint8_t usbd_control_buffer[128];

const uint8_t sysex_identity[] = {
    
        /* USB Framing (3 byte SysEx) */
	0x04,

        /* SysEx start */
	0xf0,

        /* non-realtime */
	0x7e,

        /* Channel 0 */
	0x00,

        /* USB Framing (3 byte SysEx) */
	0x04,

        /* Educational/prototype manufacturer ID */
	0x7d,

        /* Family code (byte 1) */
	0x66,

        /* Family code (byte 2) */
	0x66,

        /* USB Framing (3 byte SysEx) */
	0x04,

        /* Model number (byte 1) */
	0x51,

        /* Model number (byte 2) */
	0x19,

        /* Version number (byte 1) */
	0x00,

        /* USB Framing (3 byte SysEx) */
	0x04,

        /* Version number (byte 2) */
	0x00,

        /* Version number (byte 3) */
	0x01,

        /* Version number (byte 4) */
	0x00,

        /* USB Framing (1 byte SysEx) */
	0x05,

        /* SysEx end */
	0xf7,

        /* Padding */
	0x00,

        /* Padding */
	0x00,	
};
typedef struct {
        /* Read pointer */
	uint8_t *read;

        /* Write pointer */
	uint8_t *write;

        /* Size of the FIFO */
	size_t size;

        /* Start adress pointer */
	uint8_t *start;

        /* End adress pointer */
	uint8_t *end;

        /* current data (read return) */
	uint8_t data;

        /* is the FIFO empty -> 1=yes 0=no */
	uint8_t empty;

        /* number of midi commands (1 command = 3 8bit) */
	uint8_t midi_commands;
} FIFO;

static FIFO usb_FIFO;

static FIFO FIFO_setup(FIFO fifo, size_t size){
	fifo.size = size;

        /* 8 bit, because MIDI packets are 8 bit long */
	fifo.start = malloc(fifo.size * sizeof(uint8_t));
	fifo.end = fifo.start + size;
	fifo.write = fifo.start;
	fifo.read = fifo.start;
	return fifo;
}

static FIFO FIFO_write(FIFO fifo, uint8_t data){
	if(fifo.write == fifo.end){
		if(fifo.read != fifo.start){
			fifo.write = fifo.start;
		}else{
			/* FIFO full */
			return fifo;
		}
	}else{
		if((fifo.write + 1) != fifo.read){
			fifo.write = fifo.write + 1;
		}else{
			/* FIFO full */
			return fifo;
		}
	}
	*fifo.write = data;
	return fifo;
}


static FIFO FIFO_read(FIFO fifo){
	if(fifo.read == fifo.end){
		if(fifo.write != fifo.end){
			fifo.read = fifo.start;
		}else{
			/* FIFO empty */
			fifo.empty = 1;
			return fifo;
		}
	}else{
		if(fifo.read != fifo.write){
			fifo.read = fifo.read + 1;
		}else{
			/* FIFO empty */
			fifo.empty = 1;
			return fifo;
		}
	}

        /* write the read pointer into the data var */
	fifo.data = *fifo.read;

        /* set fifo = not empty */
	fifo.empty = 0;
	return fifo;
}

void usb_isr(usbd_device *dev, uint8_t ep){
	(void)ep;
	char buf[64];

        usbd_ep_read_packet(dev, 0x01, buf, 64);

        usb_FIFO = FIFO_write(usb_FIFO, buf[1]); /* MIDI command */
        usb_FIFO = FIFO_write(usb_FIFO, buf[2]); /* MIDI note */
        usb_FIFO = FIFO_write(usb_FIFO, buf[3]); /* MIDI velocity */
        usb_FIFO.midi_commands++;
}
static void usb_setup(usbd_device *dev, uint16_t wValue){
    (void)wValue;
    
    usbd_ep_setup(dev, 0x01,USB_ENDPOINT_ATTR_INTERRUPT, 64, usb_isr);
    usbd_ep_setup(dev,0x081, USB_ENDPOINT_ATTR_BULK,64,NULL);

    systick_set_clocksource(STK_CSR_CLKSOURCE_AHB_DIV8);
    systick_set_reload(99999);
    systick_interrupt_enable();
    systick_counter_enable();
}
void usb_lp_can_rx0_isr(void){
    usbd_poll(usbd_dev);
}
static void usb_send(usbd_device *dev){



	uint8_t midi_command = 0x91;



	
	uint8_t midi_note = 60;




	uint8_t midi_velocity = 127;

	/* MIDI Packet */	
	char buf[4] = {
		0x08,

                /* command = command 3bit (ex. note on) + channel 4bit */
		midi_command,

                /* note 0-127 */
		midi_note,

                /* velocity 0 - 127 */
		midi_velocity	
	};

	while (usbd_ep_write_packet(dev, 0x81, buf, sizeof(buf)) == 0);

}
static void loop(void){
    usb_send(usbd_dev);
    for(int i = 0; i < 500000; i++){
        __asm__("nop");
    }
}
int main(void){
    rcc_clock_setup_pll(&rcc_hse_configs[RCC_CLOCK_HSE8_72MHZ]);
    
    rcc_periph_clock_enable(RCC_GPIOA);
    rcc_periph_clock_enable(RCC_GPIOB); 
    rcc_periph_clock_enable(RCC_GPIOC);
    usb_FIFO = FIFO_setup(usb_FIFO, 64);
    nvic_enable_irq(NVIC_USB_LP_CAN_RX0_IRQ);

    usbd_dev = usbd_init(&st_usbfs_v1_usb_driver, &dev_descr,
            &config, usb_strings, 3, usbd_control_buffer,
            sizeof(usbd_control_buffer));
    
    usbd_register_set_config_callback(usbd_dev, usb_setup);
    	for (int i = 0; i < 0x800000; i++){
		__asm__("nop");
    }
    while(gpio_get(GPIOA,GPIO8) == 0){
        __asm__("nop");
        loop();
    }

}



